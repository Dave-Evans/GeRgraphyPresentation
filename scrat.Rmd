## Intro {.columns-2}

Vector data is commonly used for phenomona that have discrete boundaries, e.g., fire hydrants, streets, and buildings.
Vector data can be quickly summarized as shapes, specifically points, lines and polygons. 
Each of these are described by coordinate pairs (an X and Y) that describe either the point, trace the path of the line or enclose a polygon.

<br><br><br><br><br><br>
    
    Table here of pts, lines, polys and example graphic
examples of each
<font color="blue">**Points**</font>
    <font color="blue">**Lines**</font>
    <font color="blue">**Polygons**</font>
    
    <div class="notes">
    </div>
    ## Vector Data Terminology
    
    **Screen shot of spatial database**
    **Demo multipart features (link to JTS description of shapes)**
    
    <div class="notes">
    Vector data will commonly have more than one shape, such as 72 counties in Wisconsin or a stream dataset. Each county is a *feature* (might hear the collection referred to as a *featureclass*). Dataset attached to the spatial data is called the *attribute table* (not R terminology but generally GIS users will use this term). Each feature will have one row of the attribute data.

Most often, data are pacakged in collections, so we may have 72 polygons for the state of Wisconsin. Each of the counties (each shape) are referred to as a *feature*; this is a general rule about spatial data, each observation in the group is known as a feature. Each feature will have other data attached to it, these are known as *attributes* (for the entire dataset this often called the *attribute table*). As an example, the attributes of a soils dataset will decribe the sand and clay percentage for each polygon or for ward data they may hold the population information.
</div>
    
    ## Vector I/O
    
    ```{r}
library(rgdal)
```

<div class="notes">
    To read in the data we'll use the rgdal package (which is the R implentation of the GDAL suite of tools). Our data is in the form of shapefiles, but that doesn't concern us here (a shapefile is comprise of several different files, so we leave off the extensions) and we just tell 'readOGR()' where our data is and what the name of the file is. We'll also show a plot of what we're working with as well as miscellaneous functions to help us tell us what we're working with.
</div>

## Vector I/O

```{r}
soils = readOGR(dsn="data", layer="soilsData")
```
```{r eval=FALSE}
writeOGR(
soils,
"data",
"soilsData_out",
driver="ESRI Shapefile"
)
```

<div class="notes">
You can see that as we read it in, R tells us how many features, how many soil polygons, are in the data we just read in and how many fields are in the attribute table. Shapefiles are the most common non-database format for spatial data, but later we will cover working with a table of points.
</div>

## Vector data structure
Some helper functions

```{r}
class(soils)
slotNames(soils)
length(soils)
```

## Vector data structure {.smaller}

Take a peak here at the top of our attribute table

```{r}
str(soils@data[,1:10])
```

## Vector data structure {.smaller}

```{r}
str(soils@polygons[1])
```

*You probably don't want to call ```head()``` or ```str()``` on a large spatial object, as this spits out the first six features and all their attributes

## Vector data structure

Index the first feature with a slice (note this will also grab its data)
```{r}
poly_1 = soils[1,]
```
Use the ```subset()``` function just as you would on a normal dataframe
```{r}
silty = subset(soils, Silt1 > 70)
```

## Plotting {.columns-2}

```{r eval=FALSE}
plot(
    soils,
    main="Soils from Western WI",
    col=rainbow(5)
)
```
<br><br><br><br><br><br><br><br><br><br><br>
    ```{r echo=F, fig.width=4, fig.height=5}
par(bg=NA)
plot(
    soils,
    main="Soils from Western WI",
    col=rainbow(5)
)
```

## Working with Vector Data | Overlay Analysis
Scenario: we are tasked with finding wells susceptible to contamination, that is wells location in areas of sandy soils. 
```
# Pseudo-code
1) Read in point data
1.5) Covert to spatial data
2) Read in soils
3) Perform relational analysis to find soil properties at well locations 
4) Select those wells with high sand
```
## Vector Overlay {.smaller}

```{r}
wells = read.delim("./data/WellLocations.tsv")
class(wells); head(wells)
coordinates(wells) <- ~ x + y
class(wells)
```

## Vector Overlay {.columns-2}
Plot out to see where our points lie

```{r eval=FALSE}
soils = readOGR(
    dsn="data",
    layer="soilsData")
plot(
    soils,
    main="Soils from Western WI",
    col=rainbow(5)
)
plot(
    wells,
    add=T
)
```
<br><br><br><br><br><br><br><br><br><br><br>
    ```{r echo=F, fig.width=4, fig.height=5}
par(bg=NA)
plot(
    soils,
    main="Soils from Western WI",
    col=rainbow(5)
)
plot(
    wells,
    add=T
)
```
Hmmmmm, where are the well points?

## Coordinate Reference Systems in Brief {.smaller}
Coordinate reference systems are ways of referencing X and Y (longitude and latitdue) to specific points on the Earth. When they don't match, identical points won't lay on top of one another.
```{r}
print(wells@proj4string)
print(soils@proj4string)

print(coordinates(soils)[1:2]);print(coordinates(wells)[1:2]);
```
<div class="notes">
    Errors like this, and I still make them are how I learned about coordinate reference systems, so we'll take a brief little diversion here to explain how to deal with this. Notice here how there is no information associated with the points but there is with the soils. Also just note how the coordinates look (and its not always so easy to tell) but you can see that we have different units! 
</div>

## Coordinate Reference Systems (cont) {.columns-2 .smaller}
Solution: _define_ the CRS then _project_ the points to CRS of the soils data
```{r eval=FALSE}
wells@proj4string = CRS(
"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
wells = spTransform(
wells,
soils@proj4string)
plot(
soils,
col=rainbow(5)
)
plot(
wells,
add=T
)
```
<br><br><br><br><br><br><br><br><br><br><br>
```{r echo=F, fig.width=4, fig.height=5}
par(bg=NA)
wells@proj4string = CRS(
"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
wells = spTransform(
wells,
soils@proj4string)
plot(
soils,
col=rainbow(5)
)
plot(
wells,
add=T
)
```

## Vector Overlay | Spatial Relationships

We'll select those soils polygons that are within a distance of each well.
Then examine them. Plot with size of point related to amount of average sand content.

Dave, make sure here to show basic spatial relationship manipulation
gIntersects(wells, soils, byid=T, returnDense=T)

<div class="notes">
    Now that we've got our two datasets in the same projection, we'll continue our analysis. We know from our plot that our points are on top of our soils, but how to we get access that information underneath the points? The meat of vector analysis are spatial relationships, are two vectors touching? Overlapping? is one covering? Or within?
</div>
    
    ## Vector Overlay | Spatial Relationships
    
    Or we can use a higher level function to extract the soils data to the points.

## Vector Analysis | Further Plotting {.smaller}
Change dataset to voting wards for Wisconsin 24th Senate District, mix of census demography data and election results.
```{r results="hide"}
wards = readOGR(
    dsn="data",
    layer="WardData"
)
```
```{r}
names(wards@data)
```

<div class="notes">
    As a second example we'll look at some election data. Our goals will be to create a (half pretty) map and construct a spatial regression model.
</div>

## Make a Map {.smaller}
Show percent of vote that was democrat with an indicator of voter turnout.
```{r eval=FALSE}
options(stringsAsFactors=F)

library(rgdal)
library(rgeos)
library(foreign)
library(classInt)
library(RColorBrewer)
library(scales)
source("./misc_scripts/function_proper_legend.r")
wards@data$SEN_PERC_DEM = with(wards@data, SEN_DEM/SEN_TOT)
wards@data$SEN_PERC_TURN = with(wards@data, SEN_TOT/PERSONS1)

wards_centroids = gCentroid(wards, byid=T)
wards_centroids = SpatialPointsDataFrame(
gCentroid(wards, byid=T), 
over(wards_centroids, wards)
)
```
<div class="notes">
If we're tasked with creating a map of senate results from the last election we might try this. Create a percent dem field and symbolize our map accordingly. Additionally we might also be interested in plotting out the voter turnout for these wards.
</div>
    
    ## Make a Map (cont) {.smaller}
    ```{r eval=FALSE}
## defining number of classes
num_classes = 6
## the color palette
pal = brewer.pal(num_classes, "RdBu")
## the class intervals to use for the colors
class_ints = classIntervals(wards@data$SEN_PERC_DEM, num_classes)
## grab the colors for plotting
colrs = findColours(class_ints, pal)

legtxt = properLegend(colrs, 2)

plot(wards,
     col=colrs,
     main="Senate 24",
     border=NA)
```

## Make a Map (cont) {.smaller}
```{r eval=FALSE}
plot(wards_centroids,
     pch=20,
     cex=(wards_centroids@data$SEN_PERC_TURN),
     col=alpha('black', 0.5),
     add=T)

legend("topleft",
       legtxt,
       title="Proportion Democrat",
       fill=pal,
       bty='n'
)
legend("topright",
       c("20%", '50%', '80%'),
       pch=20,
       pt.cex=c(0.2, 0.5, 0.8),
       col=alpha('black', 0.5),
       bty='n',
       title="Percent\nTurnout"
)
```

## The map
```{r echo=FALSE, fig.height=5, fig.width=8, message=FALSE, warning=FALSE}
options(stringsAsFactors=F)
source("./misc_scripts/function_proper_legend.r")
library(rgdal)
library(rgeos)
library(foreign)
library(classInt)
library(RColorBrewer)
library(scales)

wards@data$SEN_PERC_DEM = with(wards@data, SEN_DEM/SEN_TOT)
wards@data$SEN_PERC_TURN = with(wards@data, SEN_TOT/PERSONS1)

wards_centroids = gCentroid(wards, byid=T)
wards_centroids = SpatialPointsDataFrame(
    gCentroid(wards, byid=T), 
    over(wards_centroids, wards)
)


## defining number of classes
num_classes = 6
## the color palette
pal = brewer.pal(num_classes, "RdBu")
## the class intervals to use for the colors
class_ints = classIntervals(wards@data$SEN_PERC_DEM, num_classes)
## grab the colors for plotting
colrs = findColours(class_ints, pal)

legtxt = properLegend(colrs, 2)

plot(wards,
     col=colrs,
     main="Senate 24",
     border=NA)

plot(wards_centroids,
     pch=20,
     cex=(wards_centroids@data$SEN_PERC_TURN),
     col=alpha('black', 0.5),
     add=T)

legend("topleft",
       legtxt,
       title="Proportion Democrat",
       fill=pal,
       bty='n'
)
legend("topright",
       c("20%", '50%', '80%'),
       pch=20,
       pt.cex=c(0.2, 0.5, 0.8),
       col=alpha('black', 0.5),
       bty='n',
       title="Percent\nTurnout"
)
# points(x=turnPos$text$x, y=turnPos$text$y, pch=1, cex=1)
# points(x=turnPos$text$x, y=turnPos$text$y, pch=20, cex=c(0.2, 0.5, 0.8), col=alpha('black', 0.5))
```

## Vectors | for modeling...



<div class="notes">
    If we're tasked with creating a map of senate results from the last election we might try this. Create a percent dem field and symbolize our map accordingly. Additionally we might also be interested in plotting out the voter turnout for these wards.

shape = readOGR(dsn, layer)
neigborhood_binary = poly2nb(shape)
list_of_weights = sb2listw(neighborhood_binary)
moran.test(shape$Column, list_of_weights, alternative="two.sided")
spat_lin_reg = spautolm(depVar ~ indVar, data=shape, family="SAR", listw=list_of_weights)
</div>
## Gotchas
- *SpatialObjects vs SpatialObjectsDataFrames
